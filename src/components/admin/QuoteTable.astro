---
/**
 * QuoteTable Component
 * Main data table for displaying quote requests
 * Supports sorting, filtering, inline editing, and row selection
 */
---

<div class="bg-white rounded-2xl shadow-sm border border-gray-200 overflow-hidden">
  <!-- Table Header with Search -->
  <div class="px-5 py-4 border-b border-gray-100 flex items-center justify-between gap-4 bg-gradient-to-r from-white to-mint-50/30">
    <div class="relative flex-1 max-w-md">
      <input
        type="text"
        id="quote-search"
        placeholder="Search quotes..."
        data-i18n-placeholder="searchQuotes"
        class="w-full pl-10 pr-4 py-2.5 text-sm border border-gray-200 rounded-xl focus:outline-none focus:ring-2 focus:ring-primary/30 focus:border-primary transition-colors bg-white"
      />
      <svg class="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
      </svg>
    </div>
    <div class="text-sm text-gray-500 bg-white px-3 py-1.5 rounded-lg border border-gray-100">
      <span id="visible-count" class="font-semibold text-primary">0</span> <span data-i18n="quotes">quotes</span>
    </div>
  </div>

  <!-- Table -->
  <div class="overflow-x-auto">
    <table class="w-full" style="table-layout: fixed;">
      <colgroup>
        <col class="hidden sm:table-column" style="width: 90px" /><!-- Created -->
        <col /><!-- Name (flexible) -->
        <col style="width: 125px" /><!-- Stage -->
        <col class="hidden lg:table-column" style="width: 65px" /><!-- Formula -->
        <col style="width: 95px" /><!-- Price -->
        <col class="hidden xs:table-column" style="width: 65px" /><!-- Qty -->
        <col class="hidden md:table-column" /><!-- Notes (flexible) -->
        <col style="width: 36px" /><!-- Actions -->
      </colgroup>
      <thead class="bg-gray-50 border-b border-gray-200">
        <tr>
          <!-- Created: 90px, left-aligned -->
          <th class="hidden sm:table-cell w-[90px] px-2 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider cursor-pointer hover:text-gray-700" data-sort="created">
            <div class="flex items-center gap-1">
              <span data-i18n="created">Created</span>
              <svg class="w-3 h-3 sort-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4" />
              </svg>
            </div>
          </th>
          <!-- Name: flexible, left-aligned -->
          <th class="px-2 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider cursor-pointer hover:text-gray-700" data-sort="name">
            <div class="flex items-center gap-1">
              <span data-i18n="name">Name</span>
              <svg class="w-3 h-3 sort-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4" />
              </svg>
            </div>
          </th>
          <!-- Stage: 125px, left-aligned -->
          <th class="w-[125px] px-2 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider cursor-pointer hover:text-gray-700" data-sort="status">
            <div class="flex items-center gap-1">
              <span data-i18n="stage">Stage</span>
              <svg class="w-3 h-3 sort-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4" />
              </svg>
            </div>
          </th>
          <!-- Formula: 65px, centered -->
          <th class="hidden lg:table-cell w-[65px] px-1 py-3 text-center text-xs font-semibold text-gray-500 uppercase tracking-wider">
            <span data-i18n="formula">Formula</span>
          </th>
          <!-- Price: 95px, centered -->
          <th class="w-[95px] px-1 py-3 text-center text-xs font-semibold text-gray-500 uppercase tracking-wider cursor-pointer hover:text-gray-700" data-sort="ourCost">
            <div class="flex items-center justify-center gap-1">
              <span data-i18n="price">Price</span>
              <svg class="w-3 h-3 sort-icon hidden sm:block" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4" />
              </svg>
            </div>
          </th>
          <!-- Qty: 65px, centered -->
          <th class="hidden xs:table-cell w-[65px] px-1 py-3 text-center text-xs font-semibold text-gray-500 uppercase tracking-wider cursor-pointer hover:text-gray-700" data-sort="orderQuantity">
            <div class="flex items-center justify-center gap-1">
              <span data-i18n="qty">Qty</span>
              <svg class="w-3 h-3 sort-icon hidden sm:block" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4" />
              </svg>
            </div>
          </th>
          <!-- Notes: flexible, left-aligned -->
          <th class="hidden md:table-cell px-2 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">
            <span data-i18n="notes">Notes</span>
          </th>
          <!-- Actions: 36px -->
          <th class="w-[36px] px-1 py-3"></th>
        </tr>
      </thead>
      <tbody id="quote-table-body" class="divide-y divide-gray-100">
        <!-- Rows will be inserted here by JavaScript -->
      </tbody>
    </table>
  </div>

  <!-- Empty search results -->
  <div id="no-results" class="hidden py-12 text-center">
    <svg class="w-12 h-12 text-gray-300 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
    </svg>
    <p class="text-gray-500" data-i18n="noMatchingQuotes">No quotes match your search</p>
  </div>

  <!-- Pagination Controls -->
  <div id="pagination-controls" class="hidden px-5 py-4 border-t border-gray-100 bg-gray-50/50">
    <div class="flex flex-col sm:flex-row items-center justify-between gap-3">
      <!-- Page Info -->
      <div class="text-sm text-gray-500">
        <span data-i18n="showing">Showing</span>
        <span id="page-start" class="font-medium text-gray-700">1</span>-<span id="page-end" class="font-medium text-gray-700">50</span>
        <span data-i18n="of">of</span>
        <span id="total-items" class="font-medium text-gray-700">0</span>
        <span data-i18n="quotes">quotes</span>
      </div>

      <!-- Pagination Buttons -->
      <div class="flex items-center gap-2">
        <button
          id="prev-page-btn"
          type="button"
          disabled
          class="px-3 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-white transition-colors"
        >
          <span class="hidden sm:inline" data-i18n="previous">Previous</span>
          <svg class="w-4 h-4 sm:hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
          </svg>
        </button>

        <div id="page-numbers" class="flex items-center gap-1">
          <!-- Page numbers will be inserted here -->
        </div>

        <button
          id="next-page-btn"
          type="button"
          disabled
          class="px-3 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-white transition-colors"
        >
          <span class="hidden sm:inline" data-i18n="next">Next</span>
          <svg class="w-4 h-4 sm:hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
          </svg>
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Document Viewer Modal -->
<div id="doc-viewer-modal" class="doc-viewer-modal">
  <div class="doc-viewer-backdrop"></div>
  <div class="doc-viewer-container">
    <!-- Header -->
    <div class="doc-viewer-header">
      <div class="doc-viewer-title">
        <span id="doc-viewer-filename" class="doc-filename"></span>
        <span id="doc-viewer-counter" class="doc-counter"></span>
      </div>
      <div class="doc-viewer-actions">
        <button type="button" id="doc-viewer-download" class="doc-viewer-btn" title="Download">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
          </svg>
        </button>
        <button type="button" id="doc-viewer-close" class="doc-viewer-btn" title="Close">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>
    </div>

    <!-- Content -->
    <div class="doc-viewer-content">
      <!-- Navigation buttons -->
      <button type="button" id="doc-viewer-prev" class="doc-nav-btn doc-nav-prev" title="Previous">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
        </svg>
      </button>

      <div id="doc-viewer-display" class="doc-viewer-display">
        <!-- Document content rendered here -->
      </div>

      <button type="button" id="doc-viewer-next" class="doc-nav-btn doc-nav-next" title="Next">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
        </svg>
      </button>
    </div>

    <!-- Footer with thumbnails -->
    <div id="doc-viewer-thumbnails" class="doc-viewer-thumbnails">
      <!-- Thumbnail strip rendered here -->
    </div>
  </div>
</div>

<style is:global>
  /*
   * IMPORTANT: Using is:global because inputs are dynamically generated via JS
   * and don't receive Astro's scoping attributes (data-astro-cid-*)
   */

  /* Row hover effect - mint tint */
  tbody tr {
    transition: background-color 0.15s ease;
  }
  tbody tr:hover {
    background-color: #f0fef4;
  }

  /* Sort icon active state - primary mint */
  th[data-sort].sort-asc .sort-icon,
  th[data-sort].sort-desc .sort-icon {
    color: #00c16e;
  }
  th[data-sort]:hover {
    color: #00c16e;
  }

  /* Status badge styles */
  .status-badge {
    display: inline-flex;
    align-items: center;
    padding: 0.25rem 0.75rem;
    border-radius: 9999px;
    font-size: 0.75rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s ease;
    /* Default colors - will be overridden by inline styles */
    background-color: #f3f4f6;
    color: #374151;
  }
  .status-badge:hover {
    filter: brightness(0.95);
  }

  /* Product pill styles */
  .product-pill {
    display: inline-flex;
    align-items: center;
    padding: 0.125rem 0.5rem;
    background-color: #f3f4f6;
    border-radius: 9999px;
    font-size: 0.75rem;
    color: #4b5563;
    white-space: nowrap;
  }
  .product-pill.more {
    background-color: #e5e7eb;
    color: #6b7280;
  }

  /* Inline editable input styles - mint theme */
  .inline-input {
    display: block;
    width: 100%;
    min-width: 0;  /* Allow shrinking below browser default */
    max-width: 100%;
    padding: 0.25rem 0.125rem;  /* Reduced horizontal padding for narrow columns */
    font-size: 0.875rem; /* text-sm = 14px */
    text-align: center;
    border: 1px solid transparent;
    border-radius: 0.25rem;
    background-color: transparent;
    transition: background-color 0.15s ease, border-color 0.15s ease;
    box-sizing: border-box;
  }
  .inline-input:hover {
    background-color: #f0fef4;
    border-color: #d1fae5;
  }
  .inline-input:focus {
    outline: none;
    background-color: white;
    border-color: #00c16e;
  }
  .inline-input.saving {
    background-color: #fef3c7;
    border-color: #fcd34d;
  }
  .inline-input.saved {
    background-color: #d1fae5;
    border-color: #00c16e;
  }
  .inline-input::placeholder {
    color: #9ca3af;
  }


  /* Formula thumbnail styles */
  .formula-thumbnail {
    width: 40px;
    height: 40px;
  }
  .formula-thumbnail img {
    width: 40px;
    height: 40px;
    object-fit: cover;
    border-radius: 0.5rem;
    border: 1px solid #e5e7eb;
    cursor: pointer;
    transition: all 0.15s ease;
  }
  .formula-thumbnail img:hover {
    border-color: #00c16e;
    box-shadow: 0 0 0 2px rgba(0, 193, 110, 0.15);
    transform: scale(1.05);
  }
  .formula-thumbnail .pdf-icon {
    width: 40px;
    height: 40px;
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    border-radius: 0.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.15s ease;
  }
  .formula-thumbnail .pdf-icon:hover {
    transform: scale(1.05);
    box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
  }
  .formula-thumbnail .pdf-icon span {
    color: white;
    font-size: 0.65rem;
    font-weight: 700;
    letter-spacing: 0.025em;
  }
  .formula-thumbnail .no-doc {
    width: 40px;
    height: 40px;
    background-color: #f3f4f6;
    border-radius: 0.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #9ca3af;
  }

  /* Formula thumbnail with documents indicator - green border */
  .formula-thumbnail.has-documents {
    border: 2px solid #00c16e;
    border-radius: 0.5rem;
    padding: 1px;
    position: relative;
  }

  /* Document count badge */
  .formula-thumbnail .doc-count-badge {
    position: absolute;
    top: -6px;
    right: -6px;
    min-width: 18px;
    height: 18px;
    padding: 0 5px;
    background-color: #00c16e;
    color: white;
    font-size: 0.7rem;
    font-weight: 600;
    border-radius: 9px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    z-index: 1;
  }

  /* Document hover preview popup */
  .doc-preview-popup {
    position: fixed;
    z-index: 100;
    background: white;
    border-radius: 0.75rem;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2), 0 0 0 1px rgba(0, 0, 0, 0.05);
    padding: 0.75rem;
    pointer-events: none;
    opacity: 0;
    transform: scale(0.95);
    transition: opacity 0.15s ease, transform 0.15s ease;
    max-width: 90vw;
    max-height: 85vh;
    overflow: hidden;
  }
  .doc-preview-popup.visible {
    opacity: 1;
    transform: scale(1);
  }
  .doc-preview-popup img {
    max-width: min(600px, 80vw);
    max-height: min(700px, 75vh);
    border-radius: 0.5rem;
    object-fit: contain;
    display: block;
  }
  .doc-preview-popup .pdf-preview {
    width: min(500px, 70vw);
    height: min(400px, 50vh);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
    border-radius: 0.5rem;
    color: #dc2626;
  }
  .doc-preview-popup .pdf-preview svg {
    width: 80px;
    height: 80px;
    margin-bottom: 1.5rem;
  }
  .doc-preview-popup .pdf-preview .filename {
    font-size: 1rem;
    font-weight: 500;
    max-width: 90%;
    text-align: center;
    word-break: break-word;
    padding: 0 1rem;
  }
  .doc-preview-popup .pdf-preview .hint {
    font-size: 0.875rem;
    color: #9ca3af;
    margin-top: 0.75rem;
  }
  .doc-preview-popup .loading {
    width: min(400px, 60vw);
    height: min(300px, 40vh);
    display: flex;
    align-items: center;
    justify-content: center;
    background: #f9fafb;
    border-radius: 0.5rem;
  }

  /* Document Viewer Modal */
  .doc-viewer-modal {
    position: fixed;
    inset: 0;
    z-index: 200;
    display: none;
  }
  .doc-viewer-modal.open {
    display: block;
  }
  .doc-viewer-backdrop {
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.9);
    backdrop-filter: blur(4px);
  }
  .doc-viewer-container {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
  }
  .doc-viewer-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1rem 1.5rem;
    background: rgba(0, 0, 0, 0.5);
    color: white;
    z-index: 1;
  }
  .doc-viewer-title {
    display: flex;
    align-items: center;
    gap: 1rem;
    min-width: 0;
  }
  .doc-filename {
    font-size: 1rem;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 400px;
  }
  .doc-counter {
    font-size: 0.875rem;
    color: rgba(255, 255, 255, 0.7);
    white-space: nowrap;
  }
  .doc-viewer-actions {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }
  .doc-viewer-btn {
    padding: 0.5rem;
    color: rgba(255, 255, 255, 0.8);
    border-radius: 0.5rem;
    transition: all 0.15s ease;
  }
  .doc-viewer-btn:hover {
    background: rgba(255, 255, 255, 0.1);
    color: white;
  }
  .doc-viewer-content {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
    padding: 1rem;
  }
  .doc-viewer-display {
    max-width: 100%;
    max-height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .doc-viewer-display img {
    max-width: 90vw;
    max-height: calc(100vh - 200px);
    object-fit: contain;
    border-radius: 0.5rem;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  }
  .doc-viewer-display iframe {
    width: 90vw;
    height: calc(100vh - 200px);
    border: none;
    border-radius: 0.5rem;
    background: white;
  }
  .doc-viewer-display .loading-spinner {
    color: white;
  }

  /* Navigation buttons */
  .doc-nav-btn {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 48px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.5);
    color: white;
    border-radius: 50%;
    transition: all 0.15s ease;
    z-index: 2;
  }
  .doc-nav-btn:hover {
    background: rgba(0, 0, 0, 0.7);
  }
  .doc-nav-btn:disabled {
    opacity: 0.3;
    cursor: not-allowed;
  }
  .doc-nav-btn:disabled:hover {
    background: rgba(0, 0, 0, 0.5);
  }
  .doc-nav-prev {
    left: 1rem;
  }
  .doc-nav-next {
    right: 1rem;
  }

  /* Thumbnail strip */
  .doc-viewer-thumbnails {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.75rem;
    padding: 1rem;
    background: rgba(0, 0, 0, 0.5);
    overflow-x: auto;
  }
  .doc-thumb {
    width: 60px;
    height: 60px;
    border-radius: 0.5rem;
    overflow: hidden;
    cursor: pointer;
    border: 2px solid transparent;
    transition: all 0.15s ease;
    flex-shrink: 0;
    background: #374151;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .doc-thumb:hover {
    border-color: rgba(255, 255, 255, 0.5);
  }
  .doc-thumb.active {
    border-color: #00c16e;
    box-shadow: 0 0 0 2px rgba(0, 193, 110, 0.3);
  }
  .doc-thumb img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  .doc-thumb .pdf-thumb {
    font-size: 0.65rem;
    font-weight: 700;
    color: #ef4444;
    background: #fee2e2;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* Notes cell - wrap text appropriately */
  .notes-cell {
    white-space: normal;
    word-wrap: break-word;
    line-height: 1.4;
    max-height: 3.5em; /* ~2.5 lines */
    overflow: hidden;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
  }

  /* Notes inline input - left aligned */
  .inline-input.notes-input {
    text-align: left;
    padding: 0.25rem 0.5rem;
  }
</style>

<script>
  import { t, getStageLabel as i18nGetStageLabel, formatRelativeDate as i18nFormatRelativeDate, getLanguage } from '../../utils/i18n';

  // Quote data store - now receives paginated data from server
  let currentQuotes: any[] = [];  // Current page quotes only
  let currentSort = { field: 'createdAt', direction: 'desc' };
  let searchQuery = '';
  let searchDebounceTimer: ReturnType<typeof setTimeout> | null = null;

  // Pagination state from server
  let pagination = {
    page: 1,
    limit: 50,
    hasNextPage: false,
    hasPreviousPage: false,
    totalFiltered: 0,
  };

  // Elements
  const tableBody = document.getElementById('quote-table-body');
  const searchInput = document.getElementById('quote-search') as HTMLInputElement;
  const visibleCount = document.getElementById('visible-count');
  const noResults = document.getElementById('no-results');
  const paginationControls = document.getElementById('pagination-controls');
  const prevPageBtn = document.getElementById('prev-page-btn') as HTMLButtonElement;
  const nextPageBtn = document.getElementById('next-page-btn') as HTMLButtonElement;
  const pageNumbers = document.getElementById('page-numbers');
  const pageStart = document.getElementById('page-start');
  const pageEnd = document.getElementById('page-end');
  const totalItems = document.getElementById('total-items');

  // Listen for quotes data (now paginated from server)
  window.addEventListener('quotesLoaded', (e: Event) => {
    const event = e as CustomEvent;
    currentQuotes = event.detail.quotes || [];

    // Update pagination state if provided
    if (event.detail.pagination) {
      pagination = event.detail.pagination;
    }

    // Update status counts in StatusStrip
    if (event.detail.statusCounts) {
      window.dispatchEvent(new CustomEvent('statusCountsUpdated', {
        detail: { statusCounts: event.detail.statusCounts }
      }));
    }

    renderTable();
    updatePaginationUI();
  });

  // Listen for quote updates (from inline edits or side panel)
  window.addEventListener('quoteUpdated', (e: Event) => {
    const event = e as CustomEvent;
    const updatedQuote = event.detail?.quote;
    if (!updatedQuote) return;

    // Update the quote in currentQuotes array (current page only)
    const index = currentQuotes.findIndex(q => q.id === updatedQuote.id);
    if (index !== -1) {
      currentQuotes[index] = { ...currentQuotes[index], ...updatedQuote };
    }

    // Update the specific row's inputs without full re-render
    const row = document.querySelector(`tr[data-quote-id="${updatedQuote.id}"]`);
    if (row) {
      const priceInput = row.querySelector('.price-input') as HTMLInputElement;
      const qtyInput = row.querySelector('.qty-input') as HTMLInputElement;

      if (priceInput && updatedQuote.ourCost !== undefined) {
        priceInput.value = updatedQuote.ourCost != null && updatedQuote.ourCost !== 0
          ? '$' + formatPrice(updatedQuote.ourCost)
          : '';
      }
      if (qtyInput && updatedQuote.orderQuantity !== undefined) {
        qtyInput.value = updatedQuote.orderQuantity != null && updatedQuote.orderQuantity !== 0
          ? String(updatedQuote.orderQuantity)
          : '';
      }

      const notesInput = row.querySelector('.notes-input') as HTMLInputElement;
      if (notesInput && updatedQuote.publicNotes !== undefined) {
        notesInput.value = updatedQuote.publicNotes || '';
      }
    }
  });

  // Search input handler - debounced server-side search
  searchInput?.addEventListener('input', (e) => {
    const newQuery = (e.target as HTMLInputElement).value.trim();

    // Clear existing timer
    if (searchDebounceTimer) {
      clearTimeout(searchDebounceTimer);
    }

    // Debounce search to avoid too many API calls
    searchDebounceTimer = setTimeout(() => {
      if (newQuery !== searchQuery) {
        searchQuery = newQuery;
        // Dispatch event to trigger server-side search
        window.dispatchEvent(new CustomEvent('searchChange', {
          detail: { search: searchQuery }
        }));
      }
    }, 300);
  });

  // Sort handlers - dispatch to server
  document.querySelectorAll('th[data-sort]').forEach(th => {
    th.addEventListener('click', () => {
      let field = th.getAttribute('data-sort');
      if (!field) return;

      // Map client field names to server field names
      const fieldMap: Record<string, string> = {
        'created': 'createdAt',
        'name': 'name',
        'status': 'createdAt', // Sort by created date for status (server doesn't support status sort)
        'ourCost': 'ourCost',
        'orderQuantity': 'orderQuantity',
      };
      const serverField = fieldMap[field] || 'createdAt';

      // Toggle direction if same field
      if (currentSort.field === serverField) {
        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
      } else {
        currentSort.field = serverField;
        currentSort.direction = 'asc';
      }

      // Update UI
      document.querySelectorAll('th[data-sort]').forEach(t => {
        t.classList.remove('sort-asc', 'sort-desc');
      });
      th.classList.add(`sort-${currentSort.direction}`);

      // Dispatch sort change event to trigger server request
      window.dispatchEvent(new CustomEvent('sortChange', {
        detail: {
          field: currentSort.field,
          direction: currentSort.direction
        }
      }));
    });
  });

  // Update pagination UI
  function updatePaginationUI() {
    if (!paginationControls) return;

    const { page, limit, hasNextPage, hasPreviousPage, totalFiltered } = pagination;
    const totalPages = Math.ceil(totalFiltered / limit);

    // Show/hide pagination controls
    if (totalFiltered > limit) {
      paginationControls.classList.remove('hidden');
    } else {
      paginationControls.classList.add('hidden');
      return;
    }

    // Update page info text
    const start = (page - 1) * limit + 1;
    const end = Math.min(page * limit, totalFiltered);
    if (pageStart) pageStart.textContent = String(start);
    if (pageEnd) pageEnd.textContent = String(end);
    if (totalItems) totalItems.textContent = String(totalFiltered);

    // Update prev/next buttons
    if (prevPageBtn) {
      prevPageBtn.disabled = !hasPreviousPage;
    }
    if (nextPageBtn) {
      nextPageBtn.disabled = !hasNextPage;
    }

    // Generate page numbers
    if (pageNumbers) {
      const pages: (number | string)[] = [];
      const maxVisiblePages = 5;

      if (totalPages <= maxVisiblePages) {
        // Show all pages
        for (let i = 1; i <= totalPages; i++) {
          pages.push(i);
        }
      } else {
        // Show first, last, current, and surrounding pages
        pages.push(1);

        if (page > 3) {
          pages.push('...');
        }

        for (let i = Math.max(2, page - 1); i <= Math.min(totalPages - 1, page + 1); i++) {
          if (!pages.includes(i)) {
            pages.push(i);
          }
        }

        if (page < totalPages - 2) {
          pages.push('...');
        }

        if (!pages.includes(totalPages)) {
          pages.push(totalPages);
        }
      }

      pageNumbers.innerHTML = pages.map(p => {
        if (p === '...') {
          return '<span class="px-2 py-1 text-gray-400">...</span>';
        }
        const isActive = p === page;
        return `
          <button
            type="button"
            class="page-num-btn px-3 py-1.5 text-sm font-medium rounded-lg transition-colors ${
              isActive
                ? 'bg-primary text-white'
                : 'text-gray-700 hover:bg-gray-100'
            }"
            data-page="${p}"
            ${isActive ? 'disabled' : ''}
          >
            ${p}
          </button>
        `;
      }).join('');
    }
  }

  // Pagination button handlers (using event delegation)
  prevPageBtn?.addEventListener('click', () => {
    if (pagination.hasPreviousPage) {
      window.dispatchEvent(new CustomEvent('pageChange', {
        detail: { page: pagination.page - 1 }
      }));
    }
  });

  nextPageBtn?.addEventListener('click', () => {
    if (pagination.hasNextPage) {
      window.dispatchEvent(new CustomEvent('pageChange', {
        detail: { page: pagination.page + 1 }
      }));
    }
  });

  pageNumbers?.addEventListener('click', (e) => {
    const target = e.target as HTMLElement;
    if (target.classList.contains('page-num-btn')) {
      const page = parseInt(target.getAttribute('data-page') || '1', 10);
      if (page !== pagination.page) {
        window.dispatchEvent(new CustomEvent('pageChange', {
          detail: { page }
        }));
      }
    }
  });

  // Render table rows - uses currentQuotes which is already paginated from server
  function renderTable() {
    // Re-find tableBody in case it wasn't available at script initialization
    const tbody = tableBody || document.getElementById('quote-table-body');
    if (!tbody) {
      console.error('QuoteTable: Cannot find table body element');
      return;
    }

    // Update count - show current page count
    if (visibleCount) {
      visibleCount.textContent = String(currentQuotes.length);
    }

    // Show/hide no results
    if (currentQuotes.length === 0) {
      tbody.innerHTML = '';
      noResults?.classList.remove('hidden');
      return;
    }

    noResults?.classList.add('hidden');

    // Render rows
    const unnamedText = t('unnamed');
    const viewDetailsText = t('viewDetails');

    tbody.innerHTML = currentQuotes.map(quote => {
      const createdDate = quote.createdAt
        ? formatRelativeDate(new Date(quote.createdAt))
        : 'â€”';

      const statusLabel = getStatusLabel(quote.status);
      const statusColor = getStatusBadgeColor(quote.status);
      const priceValue = quote.ourCost ? formatPrice(quote.ourCost) : '';
      const qtyValue = quote.orderQuantity || '';

      return `
        <tr data-quote-id="${quote.id}" class="cursor-pointer">
          <!-- Created: 90px, left-aligned -->
          <td class="hidden sm:table-cell w-[90px] px-2 py-3 text-left text-gray-500 text-sm whitespace-nowrap">
            ${createdDate}
          </td>
          <!-- Name: flexible, left-aligned -->
          <td class="px-2 py-3 text-left">
            <div class="font-medium text-gray-900 text-sm truncate">${escapeHtml(quote.name || unnamedText)}</div>
          </td>
          <!-- Stage: 125px, left-aligned -->
          <td class="w-[125px] px-2 py-3 text-left">
            <span class="status-badge text-sm whitespace-nowrap" data-quote-id="${quote.id}" style="background-color: ${statusColor.bg}; color: ${statusColor.text};">
              ${statusLabel}
            </span>
          </td>
          <!-- Formula: 65px, centered -->
          <td class="hidden lg:table-cell w-[65px] px-1 py-3 text-center">
            <div class="formula-thumbnail inline-block" data-quote-id="${quote.id}">
              <div class="formula-loading w-10 h-10 bg-gray-100 rounded-lg animate-pulse"></div>
            </div>
          </td>
          <!-- Price: 95px, centered -->
          <td class="w-[95px] px-1 py-3 text-center overflow-hidden">
            <input
              type="text"
              size="1"
              class="inline-input price-input"
              data-quote-id="${quote.id}"
              data-field="ourCost"
              value="${priceValue ? '$' + priceValue : ''}"
              placeholder="$0.00"
            />
          </td>
          <!-- Qty: 65px, centered -->
          <td class="hidden xs:table-cell w-[65px] px-1 py-3 text-center overflow-hidden">
            <input
              type="text"
              size="1"
              inputmode="numeric"
              pattern="[0-9]*"
              class="inline-input qty-input"
              data-quote-id="${quote.id}"
              data-field="orderQuantity"
              value="${qtyValue}"
              placeholder="0"
            />
          </td>
          <!-- Notes: flexible, left-aligned (Public Notes) -->
          <td class="hidden md:table-cell px-2 py-3 text-left overflow-hidden">
            <input
              type="text"
              class="inline-input notes-input"
              data-quote-id="${quote.id}"
              data-field="publicNotes"
              value="${escapeHtml(quote.publicNotes || '')}"
              placeholder="Add notes..."
            />
          </td>
          <!-- Actions: 36px, centered -->
          <td class="w-[36px] px-1 py-3 text-center">
            <button
              type="button"
              class="view-quote-btn p-1.5 text-gray-400 hover:text-primary hover:bg-gray-100 rounded transition-colors"
              data-quote-id="${quote.id}"
              title="${viewDetailsText}"
            >
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
              </svg>
            </button>
          </td>
        </tr>
      `;
    }).join('');

    // Load formula thumbnails for all visible quotes
    loadFormulaThumbnails();
  }

  // ============================================================================
  // EVENT DELEGATION - Single listeners on tbody for better performance
  // ============================================================================

  // Set up event delegation once (not on every render)
  const tbodyElement = document.getElementById('quote-table-body');

  // Click handler for rows, status badges, and buttons
  tbodyElement?.addEventListener('click', (e) => {
    const target = e.target as HTMLElement;
    const row = target.closest('tr[data-quote-id]');
    if (!row) return;

    const quoteId = row.getAttribute('data-quote-id');
    if (!quoteId) return;

    // Status badge click - show dropdown
    const statusBadge = target.closest('.status-badge');
    if (statusBadge) {
      e.stopPropagation();
      showStatusDropdown(statusBadge as HTMLElement, quoteId);
      return;
    }

    // Formula thumbnail click - open document
    const thumbnail = target.closest('.formula-thumbnail');
    if (thumbnail) {
      e.stopPropagation();
      const docEl = thumbnail.querySelector('[data-doc-id]');
      if (docEl) {
        const docId = docEl.getAttribute('data-doc-id');
        if (docId) {
          openDocument(quoteId, docId);
        }
      }
      return;
    }

    // View button click or inline input click - don't open panel
    if (target.closest('.inline-input')) {
      e.stopPropagation();
      return;
    }

    // Row click - open detail panel
    openQuotePanel(quoteId);
  });

  // Focus handler for price inputs (remove $ for editing)
  tbodyElement?.addEventListener('focus', (e) => {
    const target = e.target as HTMLInputElement;
    if (target.classList.contains('price-input')) {
      target.value = target.value.replace(/[$,]/g, '');
    }
  }, true); // Use capture phase for focus

  // Input handler for validation
  tbodyElement?.addEventListener('input', (e) => {
    const target = e.target as HTMLInputElement;

    if (target.classList.contains('price-input')) {
      // Allow only numbers and decimal
      let value = target.value.replace(/[^0-9.]/g, '');
      const parts = value.split('.');
      if (parts.length > 2) {
        value = parts[0] + '.' + parts.slice(1).join('');
      }
      if (parts[1]?.length > 2) {
        value = parts[0] + '.' + parts[1].slice(0, 2);
      }
      target.value = value;
    } else if (target.classList.contains('qty-input')) {
      // Allow only numbers
      target.value = target.value.replace(/[^0-9]/g, '');
    }
  });

  // Blur handler for saving inline edits
  tbodyElement?.addEventListener('blur', (e) => {
    const target = e.target as HTMLInputElement;
    if (!target.classList.contains('inline-input')) return;

    const quoteId = target.getAttribute('data-quote-id');
    if (!quoteId) return;

    if (target.classList.contains('price-input')) {
      const value = parseFloat(target.value) || 0;
      target.value = value ? '$' + formatPrice(value) : '';
      saveInlineField(quoteId, 'ourCost', value, target);
    } else if (target.classList.contains('qty-input')) {
      const value = parseInt(target.value, 10) || 0;
      target.value = value ? String(value) : '';
      saveInlineField(quoteId, 'orderQuantity', value, target);
    } else if (target.classList.contains('notes-input')) {
      const value = target.value.trim();
      saveInlineTextField(quoteId, 'publicNotes', value, target);
    }
  }, true); // Use capture phase for blur

  // Keydown handler for Enter key
  tbodyElement?.addEventListener('keydown', (e) => {
    const target = e.target as HTMLInputElement;
    if (target.classList.contains('inline-input') && (e as KeyboardEvent).key === 'Enter') {
      target.blur();
    }
  });

  // Document cache with TTL to avoid re-fetching
  interface CacheEntry {
    data: any[];
    timestamp: number;
  }
  const documentCache: Map<string, CacheEntry> = new Map();
  const CACHE_TTL = 5 * 60 * 1000; // 5 minutes
  const MAX_CACHE_SIZE = 200;

  // URL cache for preview popup
  const urlCache: Map<string, { url: string; timestamp: number }> = new Map();
  const URL_CACHE_TTL = 10 * 60 * 1000; // 10 minutes (signed URLs typically valid longer)

  // Preview popup element
  let previewPopup: HTMLElement | null = null;
  let previewTimeout: ReturnType<typeof setTimeout> | null = null;
  let currentPreviewDocId: string | null = null;

  // Create preview popup element
  function getPreviewPopup(): HTMLElement {
    if (!previewPopup) {
      previewPopup = document.createElement('div');
      previewPopup.className = 'doc-preview-popup';
      document.body.appendChild(previewPopup);
    }
    return previewPopup;
  }

  // Get cached URL or fetch new one
  async function getDocumentUrl(quoteId: string, docId: string): Promise<string | null> {
    const cacheKey = `${quoteId}:${docId}`;
    const cached = urlCache.get(cacheKey);

    if (cached && Date.now() - cached.timestamp < URL_CACHE_TTL) {
      return cached.url;
    }

    try {
      const response = await fetch(`/api/admin/quotes/${quoteId}/documents/${docId}/url`);
      if (response.ok) {
        const data = await response.json();
        if (data.url) {
          urlCache.set(cacheKey, { url: data.url, timestamp: Date.now() });
          return data.url;
        }
      }
    } catch (error) {
      console.error('Failed to get document URL:', error);
    }
    return null;
  }

  // Show preview popup
  async function showPreview(thumbnail: HTMLElement, quoteId: string, doc: any) {
    const popup = getPreviewPopup();
    currentPreviewDocId = doc.id;

    // Position popup near thumbnail - estimate size based on content type
    const rect = thumbnail.getBoundingClientRect();
    const isPdf = doc.file_type === 'application/pdf';
    const estimatedWidth = isPdf ? Math.min(500, window.innerWidth * 0.7) : Math.min(600, window.innerWidth * 0.8);
    const estimatedHeight = isPdf ? Math.min(400, window.innerHeight * 0.5) : Math.min(700, window.innerHeight * 0.75);

    // Calculate position - prefer right side, fallback to left
    let left = rect.right + 16;
    if (left + estimatedWidth > window.innerWidth - 20) {
      left = rect.left - estimatedWidth - 16;
    }
    // If still doesn't fit, center it
    if (left < 20) {
      left = Math.max(20, (window.innerWidth - estimatedWidth) / 2);
    }

    // Vertical position - align top with thumbnail, but stay in viewport
    let top = rect.top;
    top = Math.max(20, Math.min(top, window.innerHeight - estimatedHeight - 20));

    popup.style.left = `${left}px`;
    popup.style.top = `${top}px`;

    // Show loading state
    popup.innerHTML = `
      <div class="loading">
        <svg class="w-6 h-6 animate-spin text-gray-400" fill="none" viewBox="0 0 24 24">
          <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
          <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
      </div>
    `;
    popup.classList.add('visible');

    // Check if this is still the current preview
    if (currentPreviewDocId !== doc.id) return;

    if (doc.file_type === 'application/pdf') {
      // PDF preview - show icon and filename
      popup.innerHTML = `
        <div class="pdf-preview">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
          </svg>
          <div class="filename">${escapeHtml(doc.file_name)}</div>
          <div class="hint">Click to open PDF</div>
        </div>
      `;
    } else {
      // Image preview - load and display
      const url = await getDocumentUrl(quoteId, doc.id);

      // Check if this is still the current preview
      if (currentPreviewDocId !== doc.id) return;

      if (url) {
        popup.innerHTML = `<img src="${url}" alt="${escapeHtml(doc.file_name)}" />`;
      } else {
        popup.innerHTML = `
          <div class="pdf-preview">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
            </svg>
            <div class="filename">Failed to load preview</div>
          </div>
        `;
      }
    }
  }

  // Hide preview popup
  function hidePreview() {
    if (previewTimeout) {
      clearTimeout(previewTimeout);
      previewTimeout = null;
    }
    currentPreviewDocId = null;
    if (previewPopup) {
      previewPopup.classList.remove('visible');
    }
  }

  // Setup hover handlers for thumbnails (using event delegation on tbody)
  tbodyElement?.addEventListener('mouseenter', (e) => {
    const target = e.target as HTMLElement;
    const thumbnail = target.closest('.formula-thumbnail.has-documents');
    if (!thumbnail) return;

    const quoteId = thumbnail.getAttribute('data-quote-id');
    if (!quoteId) return;

    const docs = getCachedDocuments(quoteId);
    if (!docs || docs.length === 0) return;

    // Delay showing preview slightly to avoid flicker
    previewTimeout = setTimeout(() => {
      showPreview(thumbnail as HTMLElement, quoteId, docs[0]);
    }, 200);
  }, true);

  tbodyElement?.addEventListener('mouseleave', (e) => {
    const target = e.target as HTMLElement;
    const thumbnail = target.closest('.formula-thumbnail.has-documents');
    if (thumbnail) {
      hidePreview();
    }
  }, true);

  // Get cached documents if not expired
  function getCachedDocuments(quoteId: string): any[] | null {
    const entry = documentCache.get(quoteId);
    if (!entry) return null;

    if (Date.now() - entry.timestamp > CACHE_TTL) {
      documentCache.delete(quoteId);
      return null;
    }

    return entry.data;
  }

  // Cache documents with TTL
  function setCachedDocuments(quoteId: string, docs: any[]) {
    // Limit cache size - evict oldest entries
    if (documentCache.size >= MAX_CACHE_SIZE) {
      const entries = Array.from(documentCache.entries());
      entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
      // Remove oldest 25%
      const toRemove = Math.floor(MAX_CACHE_SIZE * 0.25);
      entries.slice(0, toRemove).forEach(([key]) => documentCache.delete(key));
    }

    documentCache.set(quoteId, { data: docs, timestamp: Date.now() });
  }

  // Chunk array helper
  function chunkArray<T>(arr: T[], size: number): T[][] {
    return Array.from({ length: Math.ceil(arr.length / size) }, (_, i) =>
      arr.slice(i * size, (i + 1) * size)
    );
  }

  // Load formula thumbnails using batch API
  async function loadFormulaThumbnails() {
    const thumbnails = document.querySelectorAll('.formula-thumbnail[data-quote-id]');

    // Collect IDs that need fetching (not in cache)
    const uncachedIds: string[] = [];
    const cachedThumbnails: { thumbnail: Element; quoteId: string }[] = [];

    thumbnails.forEach(thumbnail => {
      const quoteId = thumbnail.getAttribute('data-quote-id');
      if (!quoteId) return;

      const cachedDocs = getCachedDocuments(quoteId);
      if (cachedDocs !== null) {
        // Render from cache immediately
        cachedThumbnails.push({ thumbnail, quoteId });
      } else {
        uncachedIds.push(quoteId);
      }
    });

    // Render cached thumbnails first
    cachedThumbnails.forEach(({ thumbnail, quoteId }) => {
      const docs = getCachedDocuments(quoteId);
      if (docs !== null) {
        renderThumbnail(thumbnail as HTMLElement, docs, quoteId);
      }
    });

    // Batch fetch uncached documents
    if (uncachedIds.length === 0) return;

    // Fetch in batches of 20
    const chunks = chunkArray(uncachedIds, 20);

    for (const chunk of chunks) {
      try {
        const response = await fetch(`/api/admin/quotes/documents-batch?ids=${chunk.join(',')}`);
        if (!response.ok) {
          console.error('Batch document fetch failed:', response.status);
          continue;
        }

        const data = await response.json();
        if (!data.success) {
          console.error('Batch document fetch error:', data.error);
          continue;
        }

        // Cache and render each quote's documents
        Object.entries(data.documents).forEach(([quoteId, docs]) => {
          setCachedDocuments(quoteId, docs as any[]);

          // Find and render the thumbnail
          const thumbnail = document.querySelector(`.formula-thumbnail[data-quote-id="${quoteId}"]`);
          if (thumbnail) {
            renderThumbnail(thumbnail as HTMLElement, docs as any[], quoteId);
          }
        });
      } catch (error) {
        console.error('Batch document load failed:', error);
        // Render empty state for failed quotes
        chunk.forEach(quoteId => {
          setCachedDocuments(quoteId, []);
          const thumbnail = document.querySelector(`.formula-thumbnail[data-quote-id="${quoteId}"]`);
          if (thumbnail) {
            renderThumbnail(thumbnail as HTMLElement, [], quoteId);
          }
        });
      }
    }
  }

  // Render a single thumbnail
  function renderThumbnail(container: HTMLElement, documents: any[], quoteId: string) {
    if (documents.length === 0) {
      container.classList.remove('has-documents');
      const noFormulaText = t('noFormulaUploaded');
      container.innerHTML = `
        <div class="no-doc" title="${noFormulaText}">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
          </svg>
        </div>
      `;
      return;
    }

    container.classList.add('has-documents');
    const doc = documents[0]; // Show first document
    const fileType = doc.file_type;
    const docCount = documents.length;

    // Create count badge HTML (only show if more than 1 document)
    const countBadge = docCount > 1
      ? `<span class="doc-count-badge">${docCount}</span>`
      : '';

    if (fileType === 'application/pdf') {
      container.innerHTML = `
        ${countBadge}
        <div class="pdf-icon" title="${escapeHtml(doc.file_name)}" data-doc-id="${doc.id}" data-quote-id="${quoteId}">
          <span>PDF</span>
        </div>
      `;
    } else {
      // For images, we need to get a signed URL
      container.innerHTML = `
        ${countBadge}
        <div class="img-loading w-10 h-10 bg-gray-100 rounded-lg animate-pulse" data-doc-id="${doc.id}" data-quote-id="${quoteId}"></div>
      `;
      loadImageThumbnail(container, doc.id, quoteId, doc.file_name);
    }

    // Add click handler to open document
    container.addEventListener('click', async (e) => {
      e.stopPropagation();
      const docId = doc.id;
      await openDocument(quoteId, docId);
    });
  }

  // Load image thumbnail with signed URL
  async function loadImageThumbnail(container: HTMLElement, docId: string, quoteId: string, fileName: string) {
    try {
      const response = await fetch(`/api/admin/quotes/${quoteId}/documents/${docId}/url`);
      if (response.ok) {
        const data = await response.json();
        if (data.url) {
          container.innerHTML = `<img src="${data.url}" alt="${escapeHtml(fileName)}" title="${escapeHtml(fileName)}" />`;
        }
      }
    } catch (error) {
      console.error('Failed to load image thumbnail:', error);
      const failedText = t('failedToLoadImage');
      container.innerHTML = `
        <div class="no-doc" title="${failedText}">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
          </svg>
        </div>
      `;
    }
  }

  // ============================================================================
  // DOCUMENT VIEWER MODAL
  // ============================================================================

  // Document viewer state
  let viewerQuoteId: string | null = null;
  let viewerDocuments: any[] = [];
  let viewerCurrentIndex = 0;

  // Document viewer elements
  const docViewerModal = document.getElementById('doc-viewer-modal');
  const docViewerBackdrop = docViewerModal?.querySelector('.doc-viewer-backdrop');
  const docViewerClose = document.getElementById('doc-viewer-close');
  const docViewerDownload = document.getElementById('doc-viewer-download');
  const docViewerPrev = document.getElementById('doc-viewer-prev') as HTMLButtonElement;
  const docViewerNext = document.getElementById('doc-viewer-next') as HTMLButtonElement;
  const docViewerFilename = document.getElementById('doc-viewer-filename');
  const docViewerCounter = document.getElementById('doc-viewer-counter');
  const docViewerDisplay = document.getElementById('doc-viewer-display');
  const docViewerThumbnails = document.getElementById('doc-viewer-thumbnails');

  // Open document viewer with all documents for a quote
  async function openDocumentViewer(quoteId: string, startDocId?: string) {
    const docs = getCachedDocuments(quoteId);
    if (!docs || docs.length === 0) return;

    viewerQuoteId = quoteId;
    viewerDocuments = docs;

    // Find starting index
    if (startDocId) {
      const idx = docs.findIndex(d => d.id === startDocId);
      viewerCurrentIndex = idx >= 0 ? idx : 0;
    } else {
      viewerCurrentIndex = 0;
    }

    // Hide hover preview if showing
    hidePreview();

    // Show modal
    docViewerModal?.classList.add('open');
    document.body.style.overflow = 'hidden';

    // Render thumbnails
    renderViewerThumbnails();

    // Load current document
    await loadViewerDocument();
  }

  // Close document viewer
  function closeDocumentViewer() {
    docViewerModal?.classList.remove('open');
    document.body.style.overflow = '';
    viewerQuoteId = null;
    viewerDocuments = [];
    viewerCurrentIndex = 0;
    if (docViewerDisplay) docViewerDisplay.innerHTML = '';
    if (docViewerThumbnails) docViewerThumbnails.innerHTML = '';
  }

  // Navigate to previous document
  function viewerPrevious() {
    if (viewerCurrentIndex > 0) {
      viewerCurrentIndex--;
      loadViewerDocument();
      updateViewerThumbnails();
    }
  }

  // Navigate to next document
  function viewerNext() {
    if (viewerCurrentIndex < viewerDocuments.length - 1) {
      viewerCurrentIndex++;
      loadViewerDocument();
      updateViewerThumbnails();
    }
  }

  // Go to specific document by index
  function viewerGoTo(index: number) {
    if (index >= 0 && index < viewerDocuments.length) {
      viewerCurrentIndex = index;
      loadViewerDocument();
      updateViewerThumbnails();
    }
  }

  // Load and display current document
  async function loadViewerDocument() {
    if (!viewerQuoteId || !docViewerDisplay) return;

    const doc = viewerDocuments[viewerCurrentIndex];
    if (!doc) return;

    // Update header
    if (docViewerFilename) {
      docViewerFilename.textContent = doc.file_name;
    }
    if (docViewerCounter) {
      docViewerCounter.textContent = `${viewerCurrentIndex + 1} / ${viewerDocuments.length}`;
    }

    // Update navigation buttons
    if (docViewerPrev) {
      docViewerPrev.disabled = viewerCurrentIndex === 0;
    }
    if (docViewerNext) {
      docViewerNext.disabled = viewerCurrentIndex === viewerDocuments.length - 1;
    }

    // Show loading
    docViewerDisplay.innerHTML = `
      <div class="loading-spinner">
        <svg class="w-10 h-10 animate-spin" fill="none" viewBox="0 0 24 24">
          <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
          <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
      </div>
    `;

    // Get document URL
    const url = await getDocumentUrl(viewerQuoteId, doc.id);
    if (!url) {
      docViewerDisplay.innerHTML = `
        <div class="text-white text-center">
          <svg class="w-16 h-16 mx-auto mb-4 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
          </svg>
          <p>Failed to load document</p>
        </div>
      `;
      return;
    }

    // Display based on file type
    if (doc.file_type === 'application/pdf') {
      docViewerDisplay.innerHTML = `<iframe src="${url}" title="${escapeHtml(doc.file_name)}"></iframe>`;
    } else {
      docViewerDisplay.innerHTML = `<img src="${url}" alt="${escapeHtml(doc.file_name)}" />`;
    }
  }

  // Render thumbnail strip
  async function renderViewerThumbnails() {
    if (!docViewerThumbnails || !viewerQuoteId) return;

    docViewerThumbnails.innerHTML = viewerDocuments.map((doc, index) => {
      const isActive = index === viewerCurrentIndex;
      const isPdf = doc.file_type === 'application/pdf';

      return `
        <div class="doc-thumb ${isActive ? 'active' : ''}" data-index="${index}">
          ${isPdf
            ? '<div class="pdf-thumb">PDF</div>'
            : '<div class="thumb-loading w-full h-full bg-gray-600 animate-pulse"></div>'
          }
        </div>
      `;
    }).join('');

    // Load image thumbnails
    for (let i = 0; i < viewerDocuments.length; i++) {
      const doc = viewerDocuments[i];
      if (doc.file_type !== 'application/pdf') {
        const thumb = docViewerThumbnails.querySelector(`[data-index="${i}"]`);
        if (thumb) {
          const url = await getDocumentUrl(viewerQuoteId, doc.id);
          if (url) {
            thumb.innerHTML = `<img src="${url}" alt="${escapeHtml(doc.file_name)}" />`;
          }
        }
      }
    }

    // Add click handlers
    docViewerThumbnails.querySelectorAll('.doc-thumb').forEach(thumb => {
      thumb.addEventListener('click', () => {
        const index = parseInt(thumb.getAttribute('data-index') || '0', 10);
        viewerGoTo(index);
      });
    });
  }

  // Update active thumbnail
  function updateViewerThumbnails() {
    if (!docViewerThumbnails) return;

    docViewerThumbnails.querySelectorAll('.doc-thumb').forEach((thumb, index) => {
      if (index === viewerCurrentIndex) {
        thumb.classList.add('active');
      } else {
        thumb.classList.remove('active');
      }
    });
  }

  // Download current document
  async function downloadCurrentDocument() {
    if (!viewerQuoteId) return;

    const doc = viewerDocuments[viewerCurrentIndex];
    if (!doc) return;

    const url = await getDocumentUrl(viewerQuoteId, doc.id);
    if (url) {
      const a = document.createElement('a');
      a.href = url;
      a.download = doc.file_name;
      a.target = '_blank';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }
  }

  // Event listeners for document viewer
  docViewerClose?.addEventListener('click', closeDocumentViewer);
  docViewerBackdrop?.addEventListener('click', closeDocumentViewer);
  docViewerDownload?.addEventListener('click', downloadCurrentDocument);
  docViewerPrev?.addEventListener('click', viewerPrevious);
  docViewerNext?.addEventListener('click', viewerNext);

  // Keyboard navigation
  document.addEventListener('keydown', (e) => {
    if (!docViewerModal?.classList.contains('open')) return;

    switch (e.key) {
      case 'Escape':
        closeDocumentViewer();
        break;
      case 'ArrowLeft':
        viewerPrevious();
        break;
      case 'ArrowRight':
        viewerNext();
        break;
    }
  });

  // Legacy function - now opens viewer instead of new tab
  async function openDocument(quoteId: string, docId: string) {
    await openDocumentViewer(quoteId, docId);
  }

  // Save inline field with visual feedback
  async function saveInlineField(quoteId: string, field: string, value: number, inputEl: HTMLInputElement) {
    // Find quote and check if value changed
    const quote = currentQuotes.find(q => q.id === quoteId);
    if (!quote) return;

    const oldValue = quote[field] || 0;
    if (oldValue === value) return; // No change

    // Show saving state
    inputEl.classList.add('saving');
    inputEl.classList.remove('saved');

    try {
      const response = await fetch(`/api/admin/quotes/${quoteId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ [field]: value }),
      });

      if (!response.ok) throw new Error('Failed to save');

      // Update local data
      quote[field] = value;

      // Update the input value to reflect saved value
      if (field === 'ourCost') {
        inputEl.value = value ? '$' + formatPrice(value) : '';
      } else {
        inputEl.value = value ? String(value) : '';
      }

      // Show saved state
      inputEl.classList.remove('saving');
      inputEl.classList.add('saved');
      setTimeout(() => {
        inputEl.classList.remove('saved');
      }, 1500);

      // Notify panel if open - use different event name to avoid triggering our own listener
      window.dispatchEvent(new CustomEvent('quoteUpdatedFromTable', { detail: { quote } }));
    } catch (error) {
      console.error('Failed to save field:', error);
      inputEl.classList.remove('saving');
      // Revert value
      if (field === 'ourCost') {
        inputEl.value = oldValue ? '$' + formatPrice(oldValue) : '';
      } else {
        inputEl.value = oldValue ? String(oldValue) : '';
      }
    }
  }

  // Save inline text field with visual feedback (for string fields)
  async function saveInlineTextField(quoteId: string, field: string, value: string, inputEl: HTMLInputElement) {
    // Find quote and check if value changed
    const quote = currentQuotes.find(q => q.id === quoteId);
    if (!quote) return;

    const oldValue = quote[field] || '';
    if (oldValue === value) return; // No change

    // Show saving state
    inputEl.classList.add('saving');
    inputEl.classList.remove('saved');

    try {
      const response = await fetch(`/api/admin/quotes/${quoteId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ [field]: value }),
      });

      if (!response.ok) throw new Error('Failed to save');

      // Update local data
      quote[field] = value;

      // Show saved state
      inputEl.classList.remove('saving');
      inputEl.classList.add('saved');
      setTimeout(() => {
        inputEl.classList.remove('saved');
      }, 1500);

      // Notify panel if open
      window.dispatchEvent(new CustomEvent('quoteUpdatedFromTable', { detail: { quote } }));
    } catch (error) {
      console.error('Failed to save field:', error);
      inputEl.classList.remove('saving');
      // Revert value
      inputEl.value = oldValue;
    }
  }

  // Open quote detail panel
  function openQuotePanel(quoteId: string) {
    const quote = currentQuotes.find(q => q.id === quoteId);
    if (quote) {
      window.dispatchEvent(new CustomEvent('openQuotePanel', { detail: { quote } }));
    }
  }

  // Show status dropdown
  function showStatusDropdown(badge: HTMLElement, quoteId: string) {
    // Remove any existing dropdown
    document.querySelector('.status-dropdown')?.remove();

    const dropdown = document.createElement('div');
    dropdown.className = 'status-dropdown absolute z-50 bg-white border border-gray-200 rounded-lg shadow-lg py-1 min-w-[140px]';

    // Use only the allowed stages in pipeline order
    const allowedStages = ['planning', 'order_samples', 'client_review_samples', 'full_batch_order'];

    dropdown.innerHTML = allowedStages.map(status => {
      const label = getStatusLabel(status);
      const color = getStatusBadgeColor(status);
      return `
        <button
          type="button"
          class="status-option w-full px-4 py-2 text-left text-sm hover:bg-gray-100 transition-colors"
          data-status="${status}"
        >
          <span class="status-badge" style="background-color: ${color.bg}; color: ${color.text};">${label}</span>
        </button>
      `;
    }).join('');

    // Position dropdown
    const rect = badge.getBoundingClientRect();
    dropdown.style.position = 'fixed';
    dropdown.style.top = `${rect.bottom + 4}px`;
    dropdown.style.left = `${rect.left}px`;

    document.body.appendChild(dropdown);

    // Handle status selection
    dropdown.querySelectorAll('.status-option').forEach(opt => {
      opt.addEventListener('click', async () => {
        const newStatus = opt.getAttribute('data-status');
        if (newStatus) {
          await updateQuoteStatus(quoteId, newStatus);
        }
        dropdown.remove();
      });
    });

    // Close on click outside
    setTimeout(() => {
      document.addEventListener('click', function closeDropdown(e) {
        if (!dropdown.contains(e.target as Node)) {
          dropdown.remove();
          document.removeEventListener('click', closeDropdown);
        }
      });
    }, 0);
  }

  // Update quote status
  async function updateQuoteStatus(quoteId: string, status: string) {
    try {
      const response = await fetch(`/api/admin/quotes/${quoteId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ status }),
      });

      if (!response.ok) throw new Error('Failed to update');

      // Update local data for immediate UI feedback
      const quote = currentQuotes.find(q => q.id === quoteId);
      if (quote) {
        quote.status = status;
        renderTable();
      }

      // Trigger a reload to get fresh data and updated status counts
      // Use a short delay to allow the UI to update first
      setTimeout(() => {
        window.dispatchEvent(new CustomEvent('pageChange', {
          detail: { page: pagination.page }
        }));
      }, 100);
    } catch (error) {
      console.error('Failed to update status:', error);
      // Show error toast or notification
    }
  }

  // Fixed color assignments for each stage (for visual consistency)
  const stageColors: Record<string, { bg: string; text: string }> = {
    'planning': { bg: '#dbeafe', text: '#1d4ed8' },           // blue - Price Quote
    'order_samples': { bg: '#fef3c7', text: '#b45309' },      // yellow - Order Samples
    'client_review_samples': { bg: '#ede9fe', text: '#7c3aed' }, // purple - Sample Delivered
    'full_batch_order': { bg: '#d1fae5', text: '#047857' },   // green - Full Batch Order
  };

  // Get color for a status badge
  function getStatusBadgeColor(status: string): { bg: string; text: string } {
    return stageColors[status] || { bg: '#f3f4f6', text: '#374151' };
  }

  // Helper functions - use i18n
  function getStatusLabel(status: string): string {
    return i18nGetStageLabel(status);
  }

  function formatRelativeDate(date: Date): string {
    return i18nFormatRelativeDate(date);
  }

  function formatPrice(value: number): string {
    return value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  }

  function escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Update text elements with data-i18n attributes
  function updateI18nText() {
    // Update placeholder
    const searchEl = document.getElementById('quote-search') as HTMLInputElement;
    if (searchEl) {
      searchEl.placeholder = t('searchQuotes');
    }

    // Update data-i18n elements
    document.querySelectorAll('[data-i18n]').forEach(el => {
      const key = el.getAttribute('data-i18n');
      if (key) {
        el.textContent = t(key as any);
      }
    });
  }

  // Listen for language changes
  window.addEventListener('languageChanged', () => {
    // Update static text
    updateI18nText();

    // Re-render the table to update dynamic content (dates, status labels, etc.)
    renderTable();
    updatePaginationUI();
  });
</script>
